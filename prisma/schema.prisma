// Kalshi Trading Platform - Prisma Schema
// Tier 1 Foundation: Order lifecycle, Idempotency, Kill switches, Position caps, Secrets isolation

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// TIER 1: SECRETS ISOLATION (#30)
// ============================================

model ApiCredential {
  id          String   @id @default(cuid())
  name        String   // Human-readable name
  provider    String   // "kalshi", "polygon", etc.
  
  // Encrypted credentials - never exposed to frontend
  apiKey      String   @db.Text  // Encrypted
  apiSecret   String?  @db.Text  // Encrypted (optional for some providers)
  
  // Scopes and permissions
  scopes      String[] // ["read", "trade", "withdraw"]
  isActive    Boolean  @default(true)
  
  // Audit
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lastUsedAt  DateTime?
  
  @@unique([provider, name])
  @@map("api_credentials")
}

// ============================================
// TIER 1: KILL SWITCH HIERARCHY (#22)
// ============================================

enum KillSwitchLevel {
  GLOBAL        // Everything stops
  STRATEGY      // Specific strategy stops
  MARKET        // Specific market stops
  ACCOUNT       // Specific account stops
}

enum KillSwitchReason {
  MANUAL        // Human triggered
  LOSS_LIMIT    // Hit loss threshold
  ERROR_RATE    // Too many errors
  ANOMALY       // Detected unusual behavior
  EXTERNAL      // External event (API issues, etc.)
  SCHEDULED     // Planned maintenance
}

model KillSwitch {
  id          String           @id @default(cuid())
  level       KillSwitchLevel
  targetId    String?          // Strategy ID, Market ID, or Account ID (null for GLOBAL)
  
  isActive    Boolean          @default(true)
  reason      KillSwitchReason
  description String?
  
  // Who triggered it
  triggeredBy String           // "system" or user ID
  triggeredAt DateTime         @default(now())
  
  // Auto-reset configuration
  autoResetAt DateTime?        // If set, switch resets at this time
  resetBy     String?          // Who reset it
  resetAt     DateTime?
  
  // Audit trail
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  
  @@index([level, isActive])
  @@index([targetId])
  @@map("kill_switches")
}

model KillSwitchConfig {
  id              String           @id @default(cuid())
  level           KillSwitchLevel
  targetId        String?
  
  // Thresholds that trigger automatic kill
  maxDailyLoss    Decimal?         @db.Decimal(18, 8)  // Max loss before kill
  maxDrawdown     Decimal?         @db.Decimal(5, 4)   // Max drawdown percentage
  maxErrorRate    Decimal?         @db.Decimal(5, 4)   // Max errors per minute
  maxLatency      Int?             // Max API latency in ms
  
  isActive        Boolean          @default(true)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  
  @@unique([level, targetId])
  @@map("kill_switch_configs")
}

// ============================================
// TIER 1: PER-MARKET POSITION CAPS (#19)
// ============================================

model Market {
  id              String    @id @default(cuid())
  externalId      String    @unique  // Kalshi market ticker
  title           String
  category        String?
  
  // Market state
  status          String    @default("open")  // open, closed, settled
  closeTime       DateTime?
  settlementTime  DateTime?
  
  // Position cap configuration
  maxPositionSize Decimal   @default(1000) @db.Decimal(18, 8)  // Max contracts
  maxNotional     Decimal   @default(10000) @db.Decimal(18, 8) // Max $ exposure
  
  // Current aggregated position
  currentPosition Decimal   @default(0) @db.Decimal(18, 8)
  
  // Risk classification
  riskTier        Int       @default(1)  // 1=low, 2=medium, 3=high
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relations
  orders          Order[]
  positions       Position[]
  positionCaps    PositionCap[]
  
  @@index([externalId])
  @@index([status])
  @@map("markets")
}

model PositionCap {
  id              String   @id @default(cuid())
  
  // Can be market-specific or global
  marketId        String?
  market          Market?  @relation(fields: [marketId], references: [id])
  
  // Cap type
  capType         String   // "absolute", "percentage", "notional"
  
  // Thresholds
  softLimit       Decimal  @db.Decimal(18, 8)  // Warning threshold
  hardLimit       Decimal  @db.Decimal(18, 8)  // Cannot exceed
  
  // Current usage
  currentValue    Decimal  @default(0) @db.Decimal(18, 8)
  
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@unique([marketId, capType])
  @@map("position_caps")
}

model Position {
  id              String   @id @default(cuid())
  marketId        String
  market          Market   @relation(fields: [marketId], references: [id])
  
  side            String   // "yes" or "no"
  quantity        Decimal  @db.Decimal(18, 8)
  avgPrice        Decimal  @db.Decimal(18, 8)
  
  // P&L tracking
  realizedPnl     Decimal  @default(0) @db.Decimal(18, 8)
  unrealizedPnl   Decimal  @default(0) @db.Decimal(18, 8)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@unique([marketId, side])
  @@index([marketId])
  @@map("positions")
}

// ============================================
// TIER 1: ORDER LIFECYCLE STATE MACHINE (#15)
// ============================================

enum OrderStatus {
  // Initial states
  PENDING_VALIDATION    // Created, awaiting validation
  PENDING_RISK_CHECK    // Passed validation, checking risk
  PENDING_SUBMISSION    // Passed risk, ready to submit
  
  // Active states
  SUBMITTED             // Sent to exchange
  ACKNOWLEDGED          // Exchange confirmed receipt
  PARTIALLY_FILLED      // Some quantity filled
  
  // Terminal states
  FILLED                // Fully executed
  CANCELLED             // Cancelled by user
  REJECTED              // Rejected by exchange
  EXPIRED               // Time-in-force expired
  FAILED                // System error
}

enum OrderSide {
  YES
  NO
}

enum OrderType {
  MARKET
  LIMIT
}

enum TimeInForce {
  GTC   // Good til cancelled
  IOC   // Immediate or cancel
  FOK   // Fill or kill
  GTD   // Good til date
}

model Order {
  id                String       @id @default(cuid())
  
  // IDEMPOTENCY KEY - Critical for #14
  idempotencyKey    String       @unique
  
  // External references
  externalOrderId   String?      @unique  // Kalshi order ID
  marketId          String
  market            Market       @relation(fields: [marketId], references: [id])
  
  // Order details
  side              OrderSide
  type              OrderType
  timeInForce       TimeInForce  @default(GTC)
  
  // Quantities and prices
  requestedQty      Decimal      @db.Decimal(18, 8)
  filledQty         Decimal      @default(0) @db.Decimal(18, 8)
  remainingQty      Decimal      @db.Decimal(18, 8)
  limitPrice        Decimal?     @db.Decimal(18, 8)
  avgFillPrice      Decimal?     @db.Decimal(18, 8)
  
  // State machine
  status            OrderStatus  @default(PENDING_VALIDATION)
  
  // Timestamps for each state transition
  validatedAt       DateTime?
  riskCheckedAt     DateTime?
  submittedAt       DateTime?
  acknowledgedAt    DateTime?
  filledAt          DateTime?
  cancelledAt       DateTime?
  rejectedAt        DateTime?
  expiredAt         DateTime?
  failedAt          DateTime?
  
  // Error tracking
  errorCode         String?
  errorMessage      String?
  retryCount        Int          @default(0)
  
  // Strategy attribution
  strategyId        String?
  signalId          String?
  
  // Audit
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  
  // Relations
  stateTransitions  OrderStateTransition[]
  fills             OrderFill[]
  
  @@index([marketId])
  @@index([status])
  @@index([idempotencyKey])
  @@index([externalOrderId])
  @@index([createdAt])
  @@map("orders")
}

// Full audit trail of state transitions
model OrderStateTransition {
  id          String      @id @default(cuid())
  orderId     String
  order       Order       @relation(fields: [orderId], references: [id])
  
  fromStatus  OrderStatus?
  toStatus    OrderStatus
  
  reason      String?
  metadata    Json?       // Additional context
  
  createdAt   DateTime    @default(now())
  
  @@index([orderId])
  @@index([createdAt])
  @@map("order_state_transitions")
}

// Individual fills for an order
model OrderFill {
  id            String   @id @default(cuid())
  orderId       String
  order         Order    @relation(fields: [orderId], references: [id])
  
  externalId    String?  // Exchange fill ID
  quantity      Decimal  @db.Decimal(18, 8)
  price         Decimal  @db.Decimal(18, 8)
  fee           Decimal  @default(0) @db.Decimal(18, 8)
  
  filledAt      DateTime @default(now())
  
  @@index([orderId])
  @@map("order_fills")
}

// ============================================
// TIER 1: IDEMPOTENT ORDER PLACEMENT (#14)
// ============================================

model IdempotencyRecord {
  id              String   @id @default(cuid())
  key             String   @unique
  
  // Request fingerprint
  requestHash     String   // Hash of the request payload
  
  // Response cache
  responseStatus  Int      // HTTP status
  responseBody    Json?    // Cached response
  
  // Tracking
  orderId         String?  // Resulting order ID if successful
  
  // Expiry
  expiresAt       DateTime
  createdAt       DateTime @default(now())
  
  @@index([key])
  @@index([expiresAt])
  @@map("idempotency_records")
}

// ============================================
// AUDIT & MONITORING
// ============================================

model AuditLog {
  id          String   @id @default(cuid())
  
  action      String   // "order.created", "killswitch.triggered", etc.
  entityType  String   // "order", "killswitch", etc.
  entityId    String
  
  actor       String   // "system", user ID, or strategy ID
  metadata    Json?
  
  createdAt   DateTime @default(now())
  
  @@index([entityType, entityId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

model SystemMetric {
  id          String   @id @default(cuid())
  
  name        String   // "order_latency", "error_rate", etc.
  value       Decimal  @db.Decimal(18, 8)
  tags        Json?    // {"market": "BTC", "strategy": "momentum"}
  
  recordedAt  DateTime @default(now())
  
  @@index([name, recordedAt])
  @@map("system_metrics")
}

// ============================================
// ARBITRAGE DETECTION SYSTEM
// ============================================

enum ArbitrageType {
  SINGLE_MARKET    // YES + NO != $1.00
  CROSS_MARKET     // Related markets with pricing inconsistency
  TEMPORAL         // Same event, different timeframes
}

enum ArbitrageStatus {
  ACTIVE           // Opportunity still exists
  EXECUTED         // We executed the trade
  EXPIRED          // No longer profitable
  MISSED           // Disappeared before we could act
}

model ArbitrageOpportunity {
  id              String          @id @default(cuid())
  
  type            ArbitrageType
  status          ArbitrageStatus @default(ACTIVE)
  
  // Primary market info
  marketTicker    String
  marketTitle     String
  
  // For cross-market arbitrage
  relatedMarketTicker String?
  relatedMarketTitle  String?
  
  // Price data at detection time
  yesBid          Decimal         @db.Decimal(10, 4)  // Best YES bid
  yesAsk          Decimal         @db.Decimal(10, 4)  // Best YES ask
  noBid           Decimal         @db.Decimal(10, 4)  // Best NO bid
  noAsk           Decimal         @db.Decimal(10, 4)  // Best NO ask
  
  // Calculated values (in cents)
  totalCost       Decimal         @db.Decimal(10, 4)  // Cost to buy both sides
  guaranteedPayout Decimal        @db.Decimal(10, 4)  // Always $1.00 for single market
  profitCents     Decimal         @db.Decimal(10, 4)  // Profit per contract
  profitPercent   Decimal         @db.Decimal(10, 6)  // ROI percentage
  
  // Volume/liquidity info
  maxContracts    Int?            // How many contracts available at these prices
  estimatedMaxProfit Decimal?     @db.Decimal(18, 4)  // profitCents * maxContracts
  
  // Execution tracking
  executedAt      DateTime?
  executedContracts Int?
  actualProfit    Decimal?        @db.Decimal(18, 4)
  
  // Alert tracking
  alertSent       Boolean         @default(false)
  alertSentAt     DateTime?
  
  // Timestamps
  detectedAt      DateTime        @default(now())
  lastSeenAt      DateTime        @default(now())
  expiredAt       DateTime?
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  @@index([type, status])
  @@index([profitCents])
  @@index([detectedAt])
  @@index([marketTicker])
  @@map("arbitrage_opportunities")
}

// Track scan history for analytics
model ArbitrageScan {
  id              String   @id @default(cuid())
  
  marketsScanned  Int
  opportunitiesFound Int
  totalProfitPotential Decimal @db.Decimal(18, 4)
  
  scanDurationMs  Int
  
  startedAt       DateTime @default(now())
  completedAt     DateTime @default(now())
  
  @@index([startedAt])
  @@map("arbitrage_scans")
}

// Alert configuration
model ArbitrageAlertConfig {
  id              String   @id @default(cuid())
  
  // Alert thresholds
  minProfitCents  Decimal  @default(1) @db.Decimal(10, 4)  // Min profit to alert
  minProfitPercent Decimal @default(0.5) @db.Decimal(10, 6)  // Min ROI % to alert
  
  // Notification settings
  alertEnabled    Boolean  @default(true)
  webhookUrl      String?
  
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@map("arbitrage_alert_configs")
}

// ============================================
// THESIS & EVIDENCE TRACKING
// Every trade must be traceable to a thesis
// ============================================

enum ThesisStatus {
  ACTIVE           // Currently valid thesis
  EXECUTED         // Trade was placed
  INVALIDATED      // Falsification criteria met
  EXPIRED          // Time-based expiry
  SUPERSEDED       // Replaced by newer thesis
}

model Thesis {
  id                    String       @id @default(cuid())
  
  // Market reference
  marketId              String
  marketTicker          String
  
  // Core thesis
  hypothesis            String       @db.Text  // "Why" - the trading rationale
  direction             String       // "yes" or "no"
  confidence            Decimal      @db.Decimal(5, 4)  // 0-1 probability
  
  // Model attribution
  modelId               String       // Which model/strategy generated this
  modelVersion          String       // For reproducibility
  
  // Evidence
  evidenceLinks         String[]     // URLs to supporting evidence
  evidenceSummary       String?      @db.Text
  dataSnapshotId        String?
  dataSnapshot          DataSnapshot? @relation(fields: [dataSnapshotId], references: [id])
  
  // Falsification
  falsificationCriteria String       @db.Text  // When is this thesis wrong?
  invalidatedAt         DateTime?
  invalidationReason    String?
  
  // Pricing
  targetPrice           Decimal      @db.Decimal(10, 4)  // Fair value (cents)
  edgeRequired          Decimal      @default(2) @db.Decimal(10, 4)  // Min edge to trade
  maxPrice              Decimal      @default(95) @db.Decimal(10, 4)  // Don't pay more
  
  // Lifecycle
  status                ThesisStatus @default(ACTIVE)
  expiresAt             DateTime?
  
  createdAt             DateTime     @default(now())
  updatedAt             DateTime     @updatedAt
  
  // Relations
  orders                ThesisOrder[]
  
  @@index([marketId])
  @@index([modelId])
  @@index([status])
  @@index([createdAt])
  @@map("theses")
}

model ThesisOrder {
  id            String   @id @default(cuid())
  thesisId      String
  thesis        Thesis   @relation(fields: [thesisId], references: [id])
  orderId       String
  
  quantity      Int
  price         Decimal  @db.Decimal(10, 4)
  side          String   // "yes" or "no"
  status        String
  filledQty     Int      @default(0)
  avgFillPrice  Decimal? @db.Decimal(10, 4)
  
  createdAt     DateTime @default(now())
  
  @@index([thesisId])
  @@index([orderId])
  @@map("thesis_orders")
}

model DataSnapshot {
  id            String   @id @default(cuid())
  
  marketId      String
  marketTicker  String
  
  // Price data
  yesBid        Decimal  @db.Decimal(10, 4)
  yesAsk        Decimal  @db.Decimal(10, 4)
  noBid         Decimal  @db.Decimal(10, 4)
  noAsk         Decimal  @db.Decimal(10, 4)
  lastPrice     Decimal  @db.Decimal(10, 4)
  
  // Depth
  bidDepth      Int      @default(0)
  askDepth      Int      @default(0)
  spread        Decimal  @db.Decimal(10, 4)
  
  // Market stats
  volume24h     Int      @default(0)
  openInterest  Int      @default(0)
  
  // Full orderbook (JSON)
  fullOrderbook Json?
  
  // Additional metadata
  metadata      Json?
  
  capturedAt    DateTime @default(now())
  
  // Relations
  theses        Thesis[]
  
  @@index([marketId])
  @@index([capturedAt])
  @@map("data_snapshots")
}

// Performance tracking for model calibration
model ThesisPerformance {
  id                    String   @id @default(cuid())
  thesisId              String
  marketId              String
  
  // Prediction
  predictedProbability  Decimal  @db.Decimal(5, 4)
  actualOutcome         Boolean? // true = YES won, false = NO won
  brierScore            Decimal? @db.Decimal(10, 8)
  
  // P&L
  totalContracts        Int
  avgEntryPrice         Decimal  @db.Decimal(10, 4)
  exitPrice             Decimal? @db.Decimal(10, 4)
  realizedPnl           Decimal? @db.Decimal(18, 8)
  unrealizedPnl         Decimal? @db.Decimal(18, 8)
  
  // Attribution
  modelId               String
  category              String?
  
  evaluatedAt           DateTime @default(now())
  
  @@index([modelId])
  @@index([evaluatedAt])
  @@map("thesis_performance")
}

// ============================================
// DAILY P&L TRACKING
// ============================================

model DailyPnL {
  id              String   @id @default(cuid())
  date            DateTime @db.Date @unique
  
  // P&L
  realizedPnl     Decimal  @default(0) @db.Decimal(18, 8)
  unrealizedPnl   Decimal  @default(0) @db.Decimal(18, 8)
  fees            Decimal  @default(0) @db.Decimal(18, 8)
  grossPnl        Decimal  @default(0) @db.Decimal(18, 8)
  netPnl          Decimal  @default(0) @db.Decimal(18, 8)
  
  // Activity
  tradesCount     Int      @default(0)
  winCount        Int      @default(0)
  lossCount       Int      @default(0)
  positionsOpened Int      @default(0)
  positionsClosed Int      @default(0)
  
  // Drawdown
  peakPnl         Decimal  @default(0) @db.Decimal(18, 8)
  drawdown        Decimal  @default(0) @db.Decimal(18, 8)
  drawdownPct     Decimal  @default(0) @db.Decimal(10, 6)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([date])
  @@map("daily_pnl")
}

// ============================================
// STRATEGY CONFIGURATION
// ============================================

enum StrategyType {
  VALUE
  NEWS
  MARKET_MAKING
  ARBITRAGE
  HEDGING
}

enum StrategyStatus {
  ACTIVE
  PAUSED
  DISABLED
  ERROR
}

model StrategyConfig {
  id                    String         @id @default(cuid())
  name                  String
  type                  StrategyType
  
  // Execution settings
  enabled               Boolean        @default(true)
  autoExecute           Boolean        @default(false)
  maxOrdersPerHour      Int            @default(10)
  maxPositionSize       Int            @default(100)
  maxNotionalPerTrade   Decimal        @default(50) @db.Decimal(18, 8)
  
  // Risk settings
  minEdge               Decimal        @default(2) @db.Decimal(10, 4)
  minConfidence         Decimal        @default(0.55) @db.Decimal(5, 4)
  maxSpread             Decimal        @default(10) @db.Decimal(10, 4)
  minLiquidity          Int            @default(10)
  
  // Filters
  allowedCategories     String[]
  blockedCategories     String[]
  blockedMarkets        String[]
  
  // Strategy-specific params
  params                Json           @default("{}")
  
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  
  // Relations
  state                 StrategyState?
  
  @@map("strategy_configs")
}

model StrategyState {
  id                String         @id @default(cuid())
  configId          String         @unique
  config            StrategyConfig @relation(fields: [configId], references: [id])
  status            StrategyStatus @default(DISABLED)
  
  // Runtime
  lastRunAt         DateTime?
  lastSignalAt      DateTime?
  lastTradeAt       DateTime?
  
  // Errors
  errorCount        Int            @default(0)
  lastError         String?
  lastErrorAt       DateTime?
  
  // Session stats
  signalsGenerated  Int            @default(0)
  tradesExecuted    Int            @default(0)
  tradesRejected    Int            @default(0)
  pnlToday          Decimal        @default(0) @db.Decimal(18, 8)
  
  updatedAt         DateTime       @updatedAt
  
  @@map("strategy_states")
}

// ============================================
// SIGNALS
// ============================================

enum SignalType {
  ENTRY
  EXIT
  SCALE_IN
  SCALE_OUT
  HEDGE
}

enum SignalStatus {
  PENDING
  APPROVED
  REJECTED
  EXECUTED
  EXPIRED
  CANCELLED
}

model Signal {
  id              String       @id @default(cuid())
  strategyId      String
  marketId        String
  marketTicker    String
  
  // Signal details
  type            SignalType
  direction       String       // "yes" or "no"
  strength        Decimal      @db.Decimal(5, 4)
  confidence      Decimal      @db.Decimal(5, 4)
  
  // Pricing
  targetPrice     Decimal      @db.Decimal(10, 4)
  currentPrice    Decimal      @db.Decimal(10, 4)
  edge            Decimal      @db.Decimal(10, 4)
  
  // Context
  reason          String       @db.Text
  evidenceLinks   String[]
  dataSnapshotId  String?
  
  // Lifecycle
  status          SignalStatus @default(PENDING)
  thesisId        String?
  orderId         String?
  
  createdAt       DateTime     @default(now())
  evaluatedAt     DateTime?
  executedAt      DateTime?
  expiredAt       DateTime?
  
  @@index([strategyId])
  @@index([marketId])
  @@index([status])
  @@index([createdAt])
  @@map("signals")
}
